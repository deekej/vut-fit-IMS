/**
 * File:          choco_fact_sim.cc
 * Version:       0.0.0.0
 * Start date:    06-12-2013
 * Last update:   09-12-2013
 *
 * Course:        IMS (winter semester, 2013)
 * Project:       Stochastic simulation of queuing system. [Assignment #3.]
 *
 * Authors:       Daniela Srubarova (aka Aileen), 3BIT, [team-leader]
 *                David Kaspar (aka Dee'Kej), 3BIT
 * 
 * Faculty:       Faculty of Information Technologies,
 *                Brno University of Technologies,
 *                Czech Republic
 *
 * E-mails:       xsruba01@stud.fit.vutbr.cz
 *                xkaspa34@stud.fit.vutbr.cz
 *
 * Description:   Implementation of stochastic simulation of hypothetical
 *                chocolate factory queuing system. This implementation
 *                uses SimLib/C++ simulation library (version 3), which
 *                is distributed by GPLv1 license.
 *
 * NOTE:          The smallest simulation time unit is 1 minute.
 *
 * NOTE 2:        This source file is written in English, because we both
 *                agreed it's common standard and we don't like source files
 *                using Czech.
 *
 * More info @:   http://perchta.fit.vutbr.cz:8000/vyuka-ims/31
 *
 * File encoding: en_US.utf8 (United States)
 * Compiler used: gcc (GCC) 4.8.0
 *
 * TODO:          Move classes definitions to separate header files and leave
 *                here only the definitions of the classes.
 */

// #define SIMULATION_2

/* *********************************************************************************************************************************************************** *
 * ***[ START OF CHOCO_FACT_SIM.CC ]************************************************************************************************************************** *
 * *********************************************************************************************************************************************************** */


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ HEADER FILES ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

/* C++ header files. */
#include <fstream>
#include <iostream>
#include <string>

/* C header files. */
#include <cmath>
#include <cstdlib>
#include <cstring>

/* SimLib/C++ header file. */
#include <simlib.h>


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ AUXILIARY FUNCTIONS ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

void display_help(const char *prg_name)
{{{
  std::cout << prg_name << " - implementation of stochastic simulation of hypothetical chocolate" << std::endl;
  std::cout << "factory queuing system. This is the result of team project of IMS course in" << std::endl;
  std::cout << "year 2013 @ Faculty of Information Technology, Brno University of Technology," << std::endl;
  std::cout << "Czech Republic.\n" << std::endl;
  std::cout << "Authors:\tDaniela Srubarova (aka Aileen) [team-leader]" << std::endl;
  std::cout << "\t\tDavid Kaspar (aka Dee'Kej)\n" << std::endl;
  std::cout << "Contact:\txsruba01@stud.fit.vutbr.cz" << std::endl;
  std::cout << "\t\txkaspa34@stud.fit.vutbr.cz\n" << std::endl;
  std::cout << "This program is based upon SimLib/C++ (version 3) simulation library." << std::endl;
  std::cout << "If you want to start the simulation and see the results, run this program" << std::endl;
  std::cout << "without any parameters.\n" << std::endl;
  std::cout << "For more info visit: http://perchta.fit.vutbr.cz:8000/vyuka-ims/31" << std::endl;

  return;  
}}}


/**
 * Making sure that value generated by Gauss distribution will not stop the
 * simulation by planning before current Time. This function is used for
 * generating time needed for machine maintenance. The maintenance is always
 * required unless stated otherwise, therefore we're cutting the generated
 * value to the smallest simulation unit (1 minute).
 */
static inline double normal(double mean_val, double dispersion)
{{{
  double x = ceil(Normal(mean_val, dispersion));

  return (x < 1.0) ? 1.0 : x ;
}}}


void display_simulation_params(void)
{{{
  Print("+------------------------------------------------------------------------------+\n");
  Print("|                   Hypothetical chocolate factory simulation                  |\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("                            Simulation PARAMETERS:                              \n");
  Print("+------------------------------------------------------------------------------+\n\n");
  Print("New orders generation interval:       60 minutes with exponential distribution\n");
  Print("Simulation time:                 100 000 minutes (~70 days)\n\n");
  Print("+==============================================================================+\n");
  Print("Order probability of each chocolate type:\n"); 
  Print("White choc.: 13%\tMilk choc.: 49%\t\tDark choc.: 38%\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("Probability of customer leaving system if there isn't enough chocolate in store:\n");
  Print("White choc.: 17%\tMilk choc.: 26%\t\tDark choc.: 21%\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("Probability of customer buying redeeming the chocolate stock:\n");
  Print("White choc.: 31%\tMilk choc.: 28%\t\tDark choc.: 30%\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("Probability of customer informing himself about order waiting times:\n");
  Print("White choc.: 52%\tMilk choc.: 46%\t\tDark choc.: 49%\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("Probability of customer leaving due too long waiting times:\n");
  Print("White choc.: 27%\tMilk choc.: 33%\t\tDark choc.: 29%\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("Probability of customer eventually creating new order:\n");
  Print("White choc.: 73%\tMilk choc.: 67%\t\tDark choc.: 71%\n");
  Print("+------------------------------------------------------------------------------+\n\n");
  Print("NOTE: See the Petri Net visualization to see the customers' deciding process.\n\n");
  Print("===============================================================================+\n");
  Print("STORES hypothetical capacities (used for calculation of occupancy):\n");
  Print("White choc.: 750 pcs\tMilk choc.: 2000 pcs\tDark choc.: 1500 pcs\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("STORES minimal required occupancy:\n");
  Print("White choc.: 20%\tMilk choc.: 25%\t\tDark choc.: 20%\n");
  Print("+------------------------------------------------------------------------------+\n");
  Print("STORES ideal occupancy:\n");
  Print("White choc.: 30%\tMilk choc.: 75%\t\tDark choc.: 70%\n");
  Print("+------------------------------------------------------------------------------+\n\n");
  Print("      To see operation & maintenance times of each machine (facility) in the\n"
        "NOTE: new chocolate batch creation process, see the 2nd page of Petri net in\n"
        "      documentation.\n\n");
  Print("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
  Print("                            Simulation run RESULTS:                             \n");
  Print("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n");
  return;
}}}


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ CONSTANTS & DATA TYPES DECLARATIONS ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */
//{{{  -  Folding marker

/**
 * Enumeration types used for addressing array values below.
 */

enum chocolate_type {
  WHITE = 0,
  MILK,
  DARK,
  GLOBAL,
};


enum order_chances_type {
  TAKING_REST = 0,
  TRYING_COMPETITION,
  TRYING_COMPETITION2,
};


enum store_occupancy_type {
  MIN_OCCUPANCY = 0,
  ADEQUATE_OCCUPANCY,
};


enum machine_type {
  CLEANING = 0,
  ROASTING,
  SHELLING,
  GRINDING,
  REFINING,
  DEFATTING,
  CAKE_GRINDING,
  REMIXING,
  CONCHING,
  TEMPERING,
  MOLDING,
  PACKING,
};


enum gauss_params {
  MEAN_VAL = 0,
  DISPER,
};


enum operation_time {
  MIN = 0,
  MAX,
};


enum generator_state {
  DAY = 0,
  NIGHT,
  WEEKEND,
};


/**
 * Percentage values used for determining the decisions made by the customer (= new order).
 */
static double order_chances[][3] = {
  {31, 48, 27},   /* WHITE */
  {28, 54, 33},   /* MILK */
  {30, 51, 29},   /* DARK */
};


/**
 * Percentages which control if there will be any new batch created because of store
 * running below this values.
 */
static double store_occupancy[][2] = {
  {20, 30},
  {25, 75},
  {20, 70},
};


/**
 * Minimal and maximal values of machine operation time - for use with Uniform()
 * function.
 */
static double machine_oper_time[][2] = {
  {25, 50},     /* Cleaning. */
  {30, 120},    /* Roasting. */
  {15, 25},     /* Shelling. */
  {20, 30},     /* Grinding. */
  {60, 120},    /* Refining. */
  {30, 60},     /* Defatting. */
  {10, 20},     /* Cake grinding. */
  {60, 90},     /* Remixing. */
  {1440, 4320}, /* Conching. */
  {120, 180},   /* Tempering. */
  
  /* Safety mechanism - molding & packing values are result of function. Use that! */
  {0,0},
  {0,0},
};


/**
 * Maintenance times (in minutes) for each batch facility used in batch
 * process. 1st value is equal to mean value, 2nd value is equal to
 * dispersion value - both used for normal (Gauss) distribution.
 */
static double maintenance_times[][2] = {
  {15, 2},      /* Cleaning. */
  {45, 5},      /* Roasting. */
  {20, 2},      /* Shelling. */
  {10, 1},      /* Grinding. */
  {30, 4},      /* Refining. */
  {30, 3},      /* Defatting. */
  {15, 2},      /* Cake grinding. */
  {20, 2},      /* Remixing. */
  {90, 10},     /* Conching. */
  {60, 5},      /* Tempering. */
  {30, 3},      /* Molding. */
};

static const double GENERATOR_MEAN_VAL = 60;           /* In minutes. */
static const double WORKING_HOURS_LENGTH = 480;         /* In minutes. */
static const double NIGHT_TIME_LENGTH = 1440 - WORKING_HOURS_LENGTH;

static const double NEW_ORDER_WHITE_CHANCE = 13;
static const double NEW_ORDER_MILK_CHANCE = NEW_ORDER_WHITE_CHANCE + 49;

static const double ORDER_SIZE_LOW = 1;
static const double ORDER_SIZE_HIGH = 101;

static const double BATCH_MEAN_VAL = 250;
static const double BATCH_DISPERSION = 15;

static const double MOLDING_FORM_SIZE = 5;              /* Number of pieces processed at once. */
static const double MOLDING_COOLING_TIME = 30;          /* Time in minutes. */

static const double PACKING_PIECES_SIMULTANEOUSLY = 5;  /* Number of pieces simultaneously.*/
static const double PACKING_UNIT_TIME = 2;              /* Time in minutes to pack number of pieces defined above. */

static const unsigned SHELLING_MAINTENANCE_AFTER = 5;   /* Maintenance after this number of uses. */

// }}}  -  End of folding marker.

/* *********************************************************************************************************************************************************** *
 ~ ~~~[ STATISTICS & HISTOGRAMS ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

enum orders_statistics_index {
  GLOBAL_COUNT = 0,
  IMM_PROCESSED,
  TOOK_REST,
  COMPETITION,
  COMPETITION2,
  NEW_ORDER,
  NEW_BATCH,
};

enum store_statistics_index {
  EMPTIED = 0,
  BELOW_MIN,
  IDEAL_MIN,
  PRIOR_BATCH_INIT,
  NORM_BATCH_INIT,
  LONGEST_EMPTY_TIME,
};


/*
 * We're using chocolate type enumeration for indexing 2nd dimension of the array.
 */
static unsigned orders_statistics[][4] = {
  {0, 0, 0, 0},           /* GLOBAL_COUNT */
  {0, 0, 0, 0},           /* IMM_PROCESSED */
  {0, 0, 0, 0},           /* TAKING_REST */
  {0, 0, 0, 0},           /* COMPETITION */
  {0, 0, 0, 0},           /* COMPETITION2 */
  {0, 0, 0, 0},           /* NEW_ORDER */
  {0, 0, 0, 0},           /* NEW_BATCH */
};


/*
 * We're using chocolate type enumeration for indexing 2nd dimension of the array.
 */
static unsigned store_statistics[][4] = {
  {0, 0, 0, 0},           /* EMPTIED */
  {0, 0, 0, 0},           /* BELOW_MIN */
  {0, 0, 0, 0},           /* IDEAL_MIN */
  {0, 0, 0, 0},           /* PRIOR_BATCH_INIT */
  {0, 0, 0, 0},           /* NORM_BATCH_INIT */
  {0, 0, 0, 0},           /* LONGEST_EMPTY_TIME */
};

double global_machine_runtime = 0;
double global_maintenance_time = 0;


/* Histograms. */
Histogram orders_systime("of 30 days (time the orders spent in system):", 0, 1440, 30);
Histogram batches_systime("of 10 weeks (time the batches spent in system)", 0, 10080, 10);

/* Statistics. */
Stat white_store_stat("- WHITE chocolate storage:");
Stat milk_store_stat("- MILK chocolate storage");
Stat dark_store_stat("- DARK chocolate storage");


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ QUEUES ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

/**
 * Queue for each type of order.
 */
Queue white_orders_queue("- WHITE chocolate orders:");
Queue milk_orders_queue("- MILK chocolate orders:");
Queue dark_orders_queue("- DARK chocolate orders:");


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ PROCESSES & FACILITIES ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

class storehouse;

/**
 * Simulation process for new chocolate batch.
 */
class batch : public Process {
  private:
    unsigned quantity;                /* Kilograms of chocolate generated. */
    enum chocolate_type batch_type;

    storehouse *p_store;
    Queue *p_orders_queue;            /* Queue of orders waiting to be processed. */

    double start_time;

  public:
    batch(enum chocolate_type type, Priority_t priority);   /* Constructor declaration. */
    
    /**
     * Defines time spend in molding process gained upon quantity generated.
     */
    double molding_time(void)
    {{{
      return (this->quantity / MOLDING_FORM_SIZE) + MOLDING_COOLING_TIME;
    }}}
    
    /**
     * Defines time spend in packing process gained upon quantity generated.
     */
    double packing_time(void)
    {{{
      return (this->quantity / PACKING_PIECES_SIMULTANEOUSLY) * 2;
    }}}

    void Behavior(void);
};

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

/**
 * In case there is need to seize the storehouse to use it, the derived class of
 * Facility is used.
 */
class storehouse : public Facility {
  private:
    unsigned max_capacity;                      /* Maximum capacity of this store. */
    enum chocolate_type store_type;             /* Type of chocolate stored here. */
    Queue *p_queue;

    bool store_empty;
    double empty_time_start;
    double longest_empty_time;

  public:
    unsigned act_capacity;                      /* Actual capacity of this store */


    /**
     * Storehouse constructor.
     */
    storehouse(const char *name, enum chocolate_type type, unsigned max_cap, unsigned init_cap) : Facility(name)
    {{{
      this->store_type = type;
      this->max_capacity = max_cap;
      this->act_capacity = init_cap;
      this->longest_empty_time = 0;

      if (init_cap == 0x0) {
        this->empty_time_start = 0;
        this->store_empty = true;
      }
      else {
        this->store_empty = false;
      }

      switch (this->store_type) {
        case WHITE :
          this->p_queue = &white_orders_queue;
          break;
          
        case MILK :
          this->p_queue = &milk_orders_queue;
          break;

        case DARK :
          this->p_queue = &dark_orders_queue;
          break;

        default :
          break;
      };

      return;
    }}}


    /**
     * Only way how to access private member of this class and increase actual capacity.
     */
    void deposit(unsigned amount)
    {{{
      this->act_capacity += amount;

      /* Statistics. */
      switch (this->store_type) {
        case WHITE :
          white_store_stat(this->act_capacity);
          break;
          
        case MILK :
          milk_store_stat(this->act_capacity);
          break;

        case DARK :
          dark_store_stat(this->act_capacity);
          break;

        default :
          break;
      };

      if (this->store_empty == true) {
        double interval = Time - this->empty_time_start;

        if (interval > this->longest_empty_time) {
          this->longest_empty_time = interval;
          store_statistics[LONGEST_EMPTY_TIME][this->store_type] = static_cast<unsigned>(interval);
        }

        this->store_empty = false;
      }

      return;
    }}}


    /**
     * Only way how to withdraw given amount of chocolate from storehouse.
     * Method returns EXIT_FAILURE if the given amount is not in the storehouse
     * right now. Upon successful withdraw method returns EXIT_SUCCESS. It also
     * creates new chocolate batches if the actual capacity drops under
     * predefined values after the withdrawal.
     */
    int withdraw(unsigned amount)
    {{{
      if (amount > this->max_capacity) {
        std::cerr << "SIMULATION ERROR: Order is not allowed to withdraw bigger from storehouse" << std::endl;
        std::cerr << "                  than is current maximum capacity!" << std::endl;
        std::cerr << "                  Please, FIX your simulation PARAMETERS." << std::endl;

        exit(EXIT_FAILURE);
      }
      else if (amount > this->act_capacity) {
        return EXIT_FAILURE;            /* This amount can't be currently withdraw. */
      }


      this->act_capacity -= amount;

      if (this->act_capacity == 0x0) {
        this->store_empty = true;
        this->empty_time_start = Time;

        store_statistics[EMPTIED][this->store_type]++;
      }

      if (this->p_queue->Empty() == true) {

        double percentage = static_cast<double>(this->act_capacity) / static_cast<double>(this->max_capacity) * 100;

        if (percentage < store_occupancy[this->store_type][MIN_OCCUPANCY]) {
          (new batch(this->store_type, 1))->Activate();     /* Actual capacity is too low, creating preferred batch. */

          store_statistics[PRIOR_BATCH_INIT][this->store_type]++;
          store_statistics[PRIOR_BATCH_INIT][GLOBAL]++;

          store_statistics[BELOW_MIN][this->store_type]++;
          store_statistics[BELOW_MIN][GLOBAL]++;
        }

        if (percentage < store_occupancy[this->store_type][ADEQUATE_OCCUPANCY]) {
          (new batch(this->store_type, 0))->Activate();     /* Actual capacity is below adequate limit, creating normal batch. */

          store_statistics[NORM_BATCH_INIT][this->store_type]++;
          store_statistics[NORM_BATCH_INIT][GLOBAL]++;

          if (percentage >= store_occupancy[this->store_type][MIN_OCCUPANCY]) {
            store_statistics[IDEAL_MIN][this->store_type]++;
            store_statistics[IDEAL_MIN][GLOBAL]++;
          }
        }
      }

      /* Statistics. */
      switch (this->store_type) {
        case WHITE :
          white_store_stat(this->act_capacity);
          break;
          
        case MILK :
          milk_store_stat(this->act_capacity);
          break;

        case DARK :
          dark_store_stat(this->act_capacity);
          break;

        default :
          break;
      };

      return EXIT_SUCCESS;
    }}}
};

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

/* 
 * Global instances of chocolate stores. 
 */
storehouse white_store("White chocolate store", WHITE, 750, 150);
storehouse milk_store(" Milk chocolate store", MILK, 2000, 500);
storehouse dark_store(" Dark chocolate store", DARK, 1500, 300);

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

class machine;          /* To solve cross-references of machine & machine_maintenance classes. */

/**
 * Process class for simulation of maintenance of facility which will be 
 * released.
 */
class machine_maintenance : public Process {
  private:
     machine *p_machine;

  public:
    machine_maintenance(machine *p_machine, Priority_t priority) : Process(priority)
    {{{
      this->p_machine = p_machine;

      return;
    }}}
  
    void Behavior(void);
};

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

class machine : public Facility {
  public:
    unsigned char maintenance_priority;       /* Maintenance process priority. */
    unsigned use_counter;                     /* Especially used by shelling machine. */
    enum machine_type type;

    /**
     * Machine constructors. 1st is to avoid errors during compilation.
     */
    machine(void) {};

    machine(const char* name, enum machine_type type, unsigned char priority) : Facility(name)
    {{{
      this->type = type;
      this->maintenance_priority = priority;

      this->use_counter = 0;

      return;
    }}}
    
    /**
     * Method for wrapping simulation of maintenance done on current facility.
     * This method should be called before releasing this facility by standard
     * process, so we are sure that because of increased process priority it 
     * will be first to run after the following release.
     */
    void maintenance(void)
    {{{
     (new machine_maintenance(this, this->maintenance_priority))->Activate();

      return;
    }}}
};


/**
 * Definition of purely virtual method of machine_maintenance process. Because
 * of cross-reference dependencies between classes this has to be after the
 * definition of machine class.
 */
void machine_maintenance::Behavior(void)
{{{
  double maintenance_time = normal(maintenance_times[p_machine->type][MEAN_VAL], maintenance_times[p_machine->type][DISPER]);
  global_maintenance_time += maintenance_time;

  Seize(*p_machine);
  Wait(maintenance_time);
  Release(*p_machine);

  return;
}}}

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

/*
 * Global instances of machines (facilities) used during the new batch process.
 * Priority of maintenance is always higher then priority of batch processes.
 */
machine cleaning("- Cleaning machine [step #1]", CLEANING, 2);                        /* 1. */
machine roasting("- Roasting machine [step #2]", ROASTING, 2);                        /* 2. */
machine shelling("- Shelling machine [step #3]", SHELLING, 2);                        /* 3. */
machine defatting("- Defatting machine [step #6]", DEFATTING, 2);                     /* 6. */
machine cake_grinding("- Press cake grinding machine [step #7]", CAKE_GRINDING, 2);   /* 7. */
machine remixing("- Remixing machine [step #8]", REMIXING, 2);                        /* 8. */

#if   defined(SIMULATION_2)
  machine grinding("- Grinding machine [step #4 & #9]", GRINDING, 3);                  /* 4. & 9. */
  machine refining("- Refining machine [step #5 & 10]", REFINING, 3);                  /* 5. & 10. */

  machine conching1("- Conching machine #1 [step #11]", CONCHING, 2);                  /* 11. */
  machine conching2("- Conching machine #2 [step #11]", CONCHING, 2);                  /* 11. */

#elif defined(SIMULATION_3)
  machine grinding1("- Grinding machine #1 [step #4 & #9]", GRINDING, 3);              /* 4. & 9. */
  machine grinding2("- Grinding machine #2 [step #4 & #9]", GRINDING, 3);              /* 4. & 9. */

  machine refining1("- Refining machine #1 [step #5 & 10]", REFINING, 3);              /* 5. & 10. */
  machine refining2("- Refining machine #2 [step #5 & 10]", REFINING, 3);              /* 5. & 10. */

  machine conching1("- Conching machine #1 [step #11]", CONCHING, 2);                  /* 11. */
  machine conching2("- Conching machine #2 [step #11]", CONCHING, 2);                  /* 11. */
  machine conching3("- Conching machine #3 [step #11]", CONCHING, 2);                  /* 11. */
  machine conching4("- Conching machine #4 [step #11]", CONCHING, 2);                  /* 11. */

#else
  machine grinding("- Grinding machine [step #4 & #9]", GRINDING, 3);                   /* 4. & 9. */
  machine refining("- Refining machine [step #5 & 10]", REFINING, 3);                   /* 5. & 10. */
  machine conching("- Conching machine [step #11]", CONCHING, 2);                     /* 11. */

#endif

machine tempering("- Tempering machine [step #12]", TEMPERING, 2);                    /* 12. */
machine molding("- Molding machine [step #13]", MOLDING, 2);                          /* 13. */

/* Packing does not have maintenance, therefore simple Facility is sufficient. */
Facility packing("Packing facility [step #14]");                                      /* 14. */

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

/**
 * Constructor of batch class.
 */
batch::batch(enum chocolate_type type, Priority_t priority) : Process(priority)
{{{
  switch (type) {
    case WHITE :
      this->p_store = &white_store;
      this->p_orders_queue = &white_orders_queue;
      break;

    case MILK :
      this->p_store = &milk_store;
      this->p_orders_queue = &milk_orders_queue;
      break;

    case DARK :
      this->p_store = &dark_store;
      this->p_orders_queue = &dark_orders_queue;
      break;

    default :
      std::cerr << "Runtime error! Simulation got into branch in which it should not!" << std::endl;
      exit(EXIT_FAILURE);
  }

  this->batch_type = type;
  this->quantity = 0;             /* Just an safety initialization. */

  return;
}}}


class order;          /* To solve cross-references of machine & machine_maintenance classes. */


/**
 * Behaviour of chocolate creating batch process. (Required definition of virtual method.)
 */
void batch::Behavior(void)
{{{
  this->start_time = Time;

  /* 1. */
  Seize(cleaning);
  Wait(Uniform(machine_oper_time[CLEANING][MIN], machine_oper_time[CLEANING][MAX]));
  cleaning.maintenance();
  Release(cleaning);

  /* 2. */
  Seize(roasting);
  Wait(Uniform(machine_oper_time[ROASTING][MIN], machine_oper_time[ROASTING][MAX]));
  roasting.maintenance();
  Release(roasting);

  /* 3. */
  Seize(shelling);
  Wait(Uniform(machine_oper_time[SHELLING][MIN], machine_oper_time[SHELLING][MAX]));

  /* Increasing counter & testing if the time for maintenance has come. */
  shelling.use_counter++;

  if (shelling.use_counter >= SHELLING_MAINTENANCE_AFTER) {
    shelling.use_counter = 0;
    shelling.maintenance();
  }

  Release(shelling);

#if defined(SIMULATION_3)
  /* 4. */
  if (grinding1.QueueLen() < grinding2.QueueLen()) {
    Seize(grinding1);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    grinding1.maintenance();
    Release(grinding1);
  }
  else {
    Seize(grinding2);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    grinding2.maintenance();
    Release(grinding2);
  }

  /* 5. */
  if (refining1.QueueLen() < refining2.QueueLen()) {
    Seize(refining1);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    refining1.maintenance();
    Release(refining1);
  }
  else {
    Seize(refining2);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    refining2.maintenance();
    Release(refining2);
  }

#else
  /* 4. */
  Seize(grinding);
  Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
  grinding.maintenance();
  Release(grinding);

  /* 5. */
  Seize(refining);
  Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
  grinding.maintenance();
  Release(refining);
#endif

  /* 6. */
  Seize(defatting);
  Wait(Uniform(machine_oper_time[DEFATTING][MIN], machine_oper_time[DEFATTING][MAX]));
  defatting.maintenance();
  Release(defatting);
  
  /* 7. */
  Seize(cake_grinding);
  Wait(Uniform(machine_oper_time[CAKE_GRINDING][MIN], machine_oper_time[CAKE_GRINDING][MAX]));
  cake_grinding.maintenance();
  Release(cake_grinding);

  /* 8. */
  Seize(remixing);
  Wait(Uniform(machine_oper_time[REMIXING][MIN], machine_oper_time[REMIXING][MAX]));
  remixing.maintenance();
  Release(remixing);

#if defined(SIMULATION_3)
  Priority++;               /* Temporarily increasing priority to overtake line for next 2 steps. */

  /* 9. */          
  if (grinding1.QueueLen() < grinding2.QueueLen()) {
    Seize(grinding1);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    grinding1.maintenance();
    Release(grinding1);
  }
  else {
    Seize(grinding2);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    grinding2.maintenance();
    Release(grinding2);
  }

  /* 10. */
  if (refining1.QueueLen() < refining2.QueueLen()) {
    Seize(refining1);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    refining1.maintenance();
    Release(refining1);
  }
  else {
    Seize(refining2);
    Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
    refining2.maintenance();
    Release(refining2);
  }

  Priority--;               /* Restoring process priority. */

  unsigned machine = 0;
  

  /* 
   * Selecting machine with lowest queue with if-else-if construction
   * since we wasn't able to construct corresponding machine array.
   */
  if (conching1.QueueLen() < conching2.QueueLen()) {
    machine = 1;
  }
  else {
    machine = 2;
  }

  if (conching3.QueueLen() < conching4.QueueLen()) {
    if (machine == 1) {
      if (conching3.QueueLen() < conching1.QueueLen()) {
        machine = 3;
      }
    }
    else {
      if (conching3.QueueLen() < conching2.QueueLen()) {
        machine = 3;
      }
    }
  }
  else {
    if (machine == 1) {
      if (conching4.QueueLen() < conching1.QueueLen()) {
        machine = 4;
      }
    }
    else {
      if (conching4.QueueLen() < conching2.QueueLen()) {
        machine = 4;
      }
    }
  }

  /* 11. */
  switch (machine) {
    case 1 :
      Seize(conching1);
      Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
      conching1.maintenance();
      Release(conching1);
      break;

    case 2 :
      Seize(conching2);
      Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
      conching2.maintenance();
      Release(conching2);
      break;

    case 3 :
      Seize(conching3);
      Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
      conching3.maintenance();
      Release(conching3);
      break;

    case 4 :
      Seize(conching4);
      Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
      conching4.maintenance();
      Release(conching4);
      break;

    default :
      std::cerr << "Runtime error! Simulation got into branch in which it should not!" << std::endl;
      exit(EXIT_FAILURE);
  }

#else              
  /* 9. */          
  Priority++;               /* Temporarily increasing priority to overtake line for next 2 steps. */

  Seize(grinding);
  Wait(Uniform(machine_oper_time[GRINDING][MIN], machine_oper_time[GRINDING][MAX]));
  grinding.maintenance();
  Release(grinding);
  
  /* 10. */
  Seize(refining);
  Wait(Uniform(machine_oper_time[REFINING][MIN], machine_oper_time[REFINING][MAX]));
  refining.maintenance();
  Release(refining);

  Priority--;               /* Restoring process priority. */
#endif

#if defined(SIMULATION_2)
  if (conching1.QueueLen() < conching2.QueueLen()) {
    /* 11. */
    Seize(conching1);
    Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
    conching1.maintenance();
    Release(conching1);
  }
  else {
    /* 11. */
    Seize(conching2);
    Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
    conching2.maintenance();
    Release(conching2);
  }

#elif defined(SIMULATION_3)

#else
  /* 11. */
  Seize(conching);
  Wait(Uniform(machine_oper_time[CONCHING][MIN], machine_oper_time[CONCHING][MAX]));
  conching.maintenance();
  Release(conching);

#endif

  /* 12. */
  Seize(tempering);
  Wait(Uniform(machine_oper_time[TEMPERING][MIN], machine_oper_time[TEMPERING][MAX]));
  tempering.maintenance();
  Release(tempering);

  /* 
   * In this stage we know how many chocolate the batch has produced. (Batch result
   * generating here is because we want to be as much as possible close to Petri net.)
   */
   this->quantity = normal(BATCH_MEAN_VAL, BATCH_DISPERSION);

  /* 13. */
  Seize(molding);
  Wait(this->molding_time());
  molding.maintenance();
  Release(molding);

  /* 14. */
  Seize(packing);
  Wait(this->packing_time());
  Release(packing);

  
  this->p_store->deposit(this->quantity);     /* Storing produced chocolate. */
  
  batches_systime(Time - this->start_time);
  global_machine_runtime += (Time - this->start_time);
  
  if (this->p_orders_queue->Empty() == false) {
    Entity *p_next = this->p_orders_queue->GetFirst();
    p_next->Activate();
  }

  return;                                     /* The batch is finished, process is terminating. */
}}}

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

/**
 * Simulation process for new order in the system.
 */
class order : public Process {
  private:
    unsigned order_size;
    unsigned order_number;
    enum chocolate_type order_type;

    storehouse *p_store;
    Queue *p_queue;

    double start_time;

  public:
    /*
     * Constructor.
     */
    order(enum chocolate_type type) : Process()
    {{{
      switch (type) {
        case WHITE :
          this->p_store = &white_store;
          this->p_queue = &white_orders_queue;
          break;

        case MILK :
          this->p_store = &milk_store;
          this->p_queue = &milk_orders_queue;
          break;

        case DARK :
          this->p_store = &dark_store;
          this->p_queue = &dark_orders_queue;
          break;

        default :
          std::cerr << "Runtime error! Simulation got into branch in which it should not!" << std::endl;
          exit(EXIT_FAILURE);
      }
      
      this->order_type = type;

      /* static_cast<> rounds downward - keep that in mind!! */
      this->order_size = static_cast<unsigned>(Uniform(ORDER_SIZE_LOW, ORDER_SIZE_HIGH));
    }}}


    void Behavior(void)
    {{{
      this->start_time = Time;

      if (p_store->withdraw(this->order_size) == EXIT_SUCCESS) {

        /* Enough chocolate in the storehouse, order is discharged. */
        orders_statistics[IMM_PROCESSED][this->order_type]++;
        orders_statistics[IMM_PROCESSED][GLOBAL]++;

        return;
      }


      double roll = Uniform(0,100);

      /* Depleting the corresponding storehouse provisions, order is discharged. */
      if (p_store->act_capacity != 0x0 && roll <= order_chances[this->order_type][TAKING_REST]) {
        p_store->withdraw(p_store->act_capacity);

        orders_statistics[TOOK_REST][this->order_type]++;
        orders_statistics[TOOK_REST][GLOBAL]++;

        return;
      }
      /* Customer doesn't want to wait and he cancels the order. */
      else if (roll <= order_chances[this->order_type][TRYING_COMPETITION]) {
        orders_statistics[COMPETITION][this->order_type]++;
        orders_statistics[COMPETITION][GLOBAL]++;

        return;
      }

      /*
       * NOTE: The customer informs himself on the approximate ETA of finished order.
       *       Then he makes decision about creating new order or trying competition.
       *       That's why we generate new roll.
       */
      if (Uniform(0,100) <= order_chances[this->order_type][TRYING_COMPETITION2]) {
        orders_statistics[COMPETITION2][this->order_type]++;
        orders_statistics[COMPETITION2][GLOBAL]++;

        return;
      }

      orders_statistics[NEW_ORDER][this->order_type]++;
      orders_statistics[NEW_ORDER][GLOBAL]++;


      do {
        if (this->p_queue->Empty() == true) {
          Priority = 1;
        }
        
        /* This order is next, create new chocolate batch for it. */
        if (Priority == 1) {
          (new batch(this->order_type, 1))->Activate();

          orders_statistics[NEW_BATCH][this->order_type]++;
          orders_statistics[NEW_BATCH][GLOBAL]++;
        }

        /* Wait until there are enough chocolate pieces to withdraw. */
        p_queue->Insert(this);
        Passivate();

        /* Increasing priority in case it's this order turn to create new batch. */
        Priority = 1;

      } while (p_store->withdraw(this->order_size) == EXIT_FAILURE);

      
      /* 
       * Wake up another order from the queue so it can try withdraw or
       * create new batch for itself.
       */
      if (p_queue->Empty() == false) {
        order *p_next = static_cast<order *>(this->p_queue->GetFirst());
        p_next->Activate();
      }

      orders_systime(Time - this->start_time);

      return;
    }}}
};


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ EVENTS ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

/**
 * New orders generator for the chocolate factory system.
 */
class generator : public Event {
  private:
    enum generator_state state;
    bool generate_new_order;
    unsigned char day_number;

    double next_event_time;
    double working_end_time;
    double night_end_time;
    double weekend_end_time;
    

  public:
    generator(void) : Event ()
    {{{
      this->working_end_time = Time + WORKING_HOURS_LENGTH;
      this->next_event_time = Time;

      this->generate_new_order = false;
      this->day_number = 1;
      this->state = DAY;

      return;
    }}}


    void Behavior(void)
    {{{
      
      /* Finite state automata for only accepting orders which come in working hours. */
      switch(this->state) {
        case DAY :
          if (this->next_event_time < working_end_time) {
            this->generate_new_order = true;
          }
          else if (this->day_number < 5) {
            this->day_number++;
            this->state = NIGHT;
            this->night_end_time = this->working_end_time + NIGHT_TIME_LENGTH;
          }
          else {
            this->state = WEEKEND;
            this->weekend_end_time = this->working_end_time + NIGHT_TIME_LENGTH + 2880;   /* 2880 == 48 hours in minutes. */
          }

          break;

        case NIGHT :
          if (this->next_event_time > this->night_end_time) {
            this->state = DAY;
            this->generate_new_order = true;
            this->working_end_time = this->night_end_time + WORKING_HOURS_LENGTH;
          }

          break;

        case WEEKEND :
          if (this->next_event_time > this->weekend_end_time) {
            this->state = DAY;
            this->day_number = 1;
            this->generate_new_order = true;
            this->working_end_time = this->weekend_end_time + WORKING_HOURS_LENGTH;
          }
      };


      if (this->generate_new_order == true) {
        double roll = Uniform(0,100);

        if (roll <= NEW_ORDER_WHITE_CHANCE) {
          (new order(WHITE))->Activate();
          orders_statistics[GLOBAL_COUNT][WHITE]++;
        }
        else if (roll <= NEW_ORDER_MILK_CHANCE) {
          (new order(MILK))->Activate();
          orders_statistics[GLOBAL_COUNT][MILK]++;
        }
        else {
          (new order(DARK))->Activate();
          orders_statistics[GLOBAL_COUNT][DARK]++;
        }

        this->generate_new_order = false;
        orders_statistics[GLOBAL_COUNT][GLOBAL]++;
      }

      this->next_event_time = Time + ceil(Exponential(GENERATOR_MEAN_VAL));

      /* The smallest simulation time is 1 minute -> rounding. */
      this->Activate(this->next_event_time);
    }}}
};


/* *********************************************************************************************************************************************************** *
 ~ ~~~[ MAIN FUNCTION ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~
 * *********************************************************************************************************************************************************** */

int main(int argc, char* argv[])
{{{
  
  /* Any parameter used? */
  if (argc > 1) {
    display_help(argv[0]);

    if ((strcmp(argv[1],"-h") == 0) || (strcmp(argv[1], "--help") == 0)) {
      return EXIT_SUCCESS;  
    }
    
    return EXIT_FAILURE;
  }

  // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

  long seed_value;
  std::ifstream seed;
  
  seed.open("/dev/urandom", std::ifstream::binary);

  seed.read(reinterpret_cast<char *>(&seed_value), sizeof(long));
  //RandomSeed(seed_value);

  // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

  Init(0, 100000);
  (new generator())->Activate();
  Run();

  // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // 


#if defined(SIMULATION_2)
  SetOutput("simulation2.txt");
#elif defined(SIMULATION_3)
  SetOutput("simulation3.txt");
#else
  SetOutput("simulation1.txt");
#endif


  display_simulation_params();
  
  Print("Number of customers interested in:\n");
  Print("----------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[GLOBAL_COUNT][WHITE],
                            orders_statistics[GLOBAL_COUNT][MILK], orders_statistics[GLOBAL_COUNT][DARK]);

  Print("\n\n");
  Print("Number of customers immediately discharged:\n");
  Print("-------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[IMM_PROCESSED][WHITE],
                         orders_statistics[IMM_PROCESSED][MILK], orders_statistics[IMM_PROCESSED][DARK]);

  Print("\n\n");
  Print("Number of customers who fully redeeming the chocolate stock:\n");
  Print("------------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[TOOK_REST][WHITE],
                             orders_statistics[TOOK_REST][MILK], orders_statistics[TOOK_REST][DARK]);

  Print("\n\n");
  Print("Number of customers who immediately left to try competition:\n");
  Print("------------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[COMPETITION][WHITE],
                           orders_statistics[COMPETITION][MILK], orders_statistics[COMPETITION][DARK]);

  Print("\n\n");
  Print("Number of customers who left to try competition after hearing\nthe waiting times:\n");
  Print("-------------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[COMPETITION2][WHITE],
                          orders_statistics[COMPETITION2][MILK], orders_statistics[COMPETITION2][DARK]);

  Print("\n\n");
  Print("Number of customers who decided to create new order:\n");
  Print("----------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[NEW_ORDER][WHITE],
                             orders_statistics[NEW_ORDER][MILK], orders_statistics[NEW_ORDER][DARK]);

  Print("\n\n");
  Print("Number of orders which eventually created new batch in the system:\n");
  Print("------------------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", orders_statistics[NEW_BATCH][WHITE],
                             orders_statistics[NEW_BATCH][MILK], orders_statistics[NEW_BATCH][DARK]);
  Print("\n\n");

  Print("Total numbers:\n");
  Print("--------------\n");
  Print("# of customers:\t\t\t\t\t\t%u\n", orders_statistics[GLOBAL_COUNT][GLOBAL]);
  Print("# of immediately discharged customers:\t\t\t%u\n", orders_statistics[IMM_PROCESSED][GLOBAL]);
  Print("# of customers who redeemed chocolate stock:\t\t%u\n", orders_statistics[TOOK_REST][GLOBAL]);
  Print("# of customers who immediately left to for competition:\t%u\n", orders_statistics[COMPETITION][GLOBAL]);
  Print("# of customers who left to for competition afterwards:\t%u\n", orders_statistics[COMPETITION2][GLOBAL]);
  Print("# of customers who created new order:\t\t\t%u\n", orders_statistics[NEW_ORDER][GLOBAL]);
  Print("# of orders which created new chocolate batches:\t%u\n", orders_statistics[NEW_BATCH][GLOBAL]);

  Print("\n\n");

  orders_systime.Output();
  
  Print("\n+----------------------------------------------------------+\n");
  Print("                   Each queue statistics:                   \n");

  white_orders_queue.Output();
  milk_orders_queue.Output();
  dark_orders_queue.Output();

  Print("\n\n+----------------------------------------------------------+\n");
  Print("|                     STORE statistics:                    |\n");
  Print("+----------------------------------------------------------+\n");
  Print("\n");
  Print("Number of drops below MINIMAL REQUIRED value of each store:\n");
  Print("-----------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", store_statistics[BELOW_MIN][WHITE],
                              store_statistics[BELOW_MIN][MILK], store_statistics[BELOW_MIN][DARK]);

  Print("\n\n");
  Print("Number of drops below IDEAL value of each store:\n");
  Print("(Drops below MINIMAL REQUIRED value are counted separately.)\n");
  Print("------------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", store_statistics[IDEAL_MIN][WHITE],
                              store_statistics[IDEAL_MIN][MILK], store_statistics[IDEAL_MIN][DARK]);

  Print("\n\n");
  Print("Number of times when each store was completely emptied:\n");
  Print("-------------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", store_statistics[EMPTIED][WHITE],
                                store_statistics[EMPTIED][MILK], store_statistics[EMPTIED][DARK]);

  Print("\n\n");
  Print("Longest empty time of each store (in minutes):\n");
  Print("----------------------------------------------\n");
  Print("WHITE choc.: %u\tMILK choc.: %u\tDARK choc.: %u\n", store_statistics[LONGEST_EMPTY_TIME][WHITE],
                 store_statistics[LONGEST_EMPTY_TIME][MILK], store_statistics[LONGEST_EMPTY_TIME][DARK]);

  Print("\n\n");
  Print("Number of times when each store initiated creating\nof new chocolate batch with INCREASED priority:\n");
  Print("--------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", store_statistics[PRIOR_BATCH_INIT][WHITE],
                       store_statistics[PRIOR_BATCH_INIT][MILK], store_statistics[PRIOR_BATCH_INIT][DARK]);

  Print("\n\n");
  Print("Number of times when each store initiated creating\nof new chocolate batch with NORMAL priority:\n");
  Print("--------------------------------------------------\n");
  Print("WHITE choc.: %u\t\tMILK choc.: %u\t\tDARK choc.: %u\n", store_statistics[NORM_BATCH_INIT][WHITE],
                        store_statistics[NORM_BATCH_INIT][MILK], store_statistics[NORM_BATCH_INIT][DARK]);

  Print("\n\n");
  Print("Total numbers for STORES:\n");
  Print("-------------------------\n");
  Print("# of total drops below REQUIRED MINIMUM:\t\t%u\n", store_statistics[BELOW_MIN][GLOBAL]);
  Print("# of total drops below IDEAL value (without REQ. MIN.):\t%u\n", store_statistics[IDEAL_MIN][GLOBAL]);
  Print("# of total PRIORITY chocolate batches created:\t\t%u\n", store_statistics[PRIOR_BATCH_INIT][GLOBAL]);
  Print("# of total   NORMAL chocolate batches created:\t\t%u\n", store_statistics[NORM_BATCH_INIT][GLOBAL]);

  Print("\n\n");
  Print("+----------------------------------------------------------+\n");
  Print("                    Each STORE usage:                       \n");
  
  white_store_stat.Output();
  milk_store_stat.Output();
  dark_store_stat.Output();

  Print("\n\n+----------------------------------------------------------+\n");
  Print("|                  MACHINES statistics:                    |\n");
  Print("+----------------------------------------------------------+\n\n");
  Print("Line's total running time: \t%u (in minutes)\n", static_cast<unsigned>(global_machine_runtime));
  Print("Line's total maintenance time: \t%u (in minutes)\n\n", static_cast<unsigned>(global_maintenance_time));

  batches_systime.Output();

  Print("\n");
  Print("+----------------------------------------------------------+\n");
  Print("                 Each MACHINE usage data:                   \n");
  
  cleaning.Output();
  roasting.Output();
  shelling.Output();
#if defined(SIMULATION_3)
  grinding1.Output();
  grinding2.Output();
  refining1.Output();
  refining2.Output();
#else
  grinding.Output();
  refining.Output();
#endif
  defatting.Output();
  cake_grinding.Output();
  remixing.Output();
#if defined(SIMULATION_3)
  conching1.Output();
  conching2.Output();
  conching3.Output();
  conching4.Output();
#elif defined(SIMULATION_2)
  conching1.Output();
  conching2.Output();
#else
  conching.Output();
#endif
  tempering.Output();
  molding.Output();
  packing.Output();

  // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

  seed.close();

  return EXIT_SUCCESS;
}}}


/* *********************************************************************************************************************************************************** *
 * ***[ EMD OF CHOCO_FACT_SIM.CC ]**************************************************************************************************************************** *
 * *********************************************************************************************************************************************************** */

